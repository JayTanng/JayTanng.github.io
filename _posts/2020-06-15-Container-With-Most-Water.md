---
layout: default
title: "盛最多水的容器"
tag: Leetcode
---

# <a name="top"></a>盛最多水的容器

* [问题描述](#anchor1)
* [双指针法](#anchor2)

***

## <a name="anchor1"></a>问题描述

> **难度：**<font color="red">中等</font>  
> **链接：**[盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)   
> **描述：**给你$ n $个非负整数$ a_{1}，a_{2}，...，a_{n} $，每个数代表坐标中的一个点$ (i, a_{i}) $ 。在坐标内画$ n $条垂直线，垂直线$ i $的两个端点分别为$ (i, a_{i}) $和$ (i, 0) $。找出其中的两条线，使得它们与$ x $轴共同构成的容器可以容纳最多的水。     
> **说明：**你不能倾斜容器，且 n 的值至少为 2。    
> <div align="center"><img src="../assets/img/diagram/20200615_example.jpg" alt="示例1" style="width:50%; height:50%;" /></div>   
> <div class="img_title">图中垂直线代表输入数组$ [1,8,6,2,5,4,8,3,7] $。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</div>    

[[Top]](#top)

## <a name="anchor2"></a>双指针法

算法思想为：
> 初始化两个指针分别指向数组的左边界和右边界，初始化一个maxArea用来记录两个指针收缩过程中盛水的最大面积。每次移动高度较小指针向中间靠拢，每次计算盛水面积并实时更新maxArea，盛水面级公式为min(ai, aj) * (j - i)。    

**证明**    
为什么双指针的做法是正确的？
> 双指针代表了什么？    
双指针代表的是**可以作为容器边界的所有位置的范围**。在一开始，双指针指向数组的左右边界，表示**数组中所有的位置都可以作为容器的边界**，因为我们还没有进行过任何尝试。在这之后，我们每次将**对应的数字较小的那个指针**往**另一个指针**的方向移动一个位置，就表示我们认为**这个指针不可能再作为容器的边界了**。    
> 为什么对应的数字较小的那个指针不可能再作为容器的边界了？

在上面的分析部分，我们对这个问题有了一点初步的想法。这里我们定量地进行证明。

**考虑第一步**，假设当前左指针和右指针指向的数分别为$ x $和$ y $，不失一般性，我们假设$ x \leq y $。同时，两个指针之间的距离为$ t $。那么，它们组成的容器的容量为：    
$$
\min(x, y) * t = x * t
$$    
我们可以断定，**如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过$ x * t $**了。注意这里右指针只能向左移动，因为**我们考虑的是第一步**，也就是**指针还指向数组的左右边界的时候**。

我们任意向左移动右指针，指向的数为$ y_1 $，两个指针之间的距离为$ t_1 $，那么显然有$ t_1 < t $，并且 $ \min(x, y_1) \leq \min(x, y)：

* 如果$ y_1 \leq y $，那么$ \min(x, y_1) \leq \min(x, y) $；
* 如果$ y_1 > y $，那么$ \min(x, y_1) = x = \min(x, y) $。

因此有：

$$
\min(x, y_t) * t_1 < \min(x, y) * t
​$$

即无论我们怎么移动右指针，得到的容器的容量都小于移动前容器的容量。也就是说，**这个左指针对应的数不会作为容器的边界了**，那么我们就可以丢弃这个位置，**将左指针向右移动一个位置**，此时新的左指针于原先的右指针之间的左右位置，才可能会作为容器的边界。

这样以来，我们将问题的规模减小了$ 1 $，被我们丢弃的那个位置就相当于消失了。**此时的左右指针，就指向了一个新的、规模减少了的问题的数组的左右边界**，因此，我们可以继续像之前**考虑第一步**那样考虑这个问题：

* 求出当前双指针对应的容器的容量；

* 对应数字较小的那个指针以后不可能作为容器的边界了，将其丢弃，并移动对应的指针。

> 最后的答案是什么？

答案就是我们每次以双指针为左右边界（也就是「数组」的左右边界）计算出的容量中的最大值。

算法性能如下：
* 时间复杂度为**O(n)**
* 空间复杂度为**O(1)**    

算法代码如下：

``` java   
public int maxArea(int[] height) {
	int left = 0;
	int right = height.length - 1;
	int maxArea = 0;
	while (left < right) {
		int curArea = Math.min(height[left], height[right]) * (right - left);
		maxArea = maxArea > curArea ? maxArea : curArea;
		if (height[left] < height[right]) {
			left++;
		} else {
			right--;
		}
	}
	return maxArea;
}
```   
[[Top]](#top) 